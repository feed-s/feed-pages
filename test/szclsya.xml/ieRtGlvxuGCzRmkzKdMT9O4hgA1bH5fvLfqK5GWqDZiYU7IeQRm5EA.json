{
  "url": "https://szclsya.me/zh-cn/posts/storage/zfs-setup/",
  "title": "ZFS 入门指北：规划与创建存储池 - Leo's Field",
  "description": "Arrow Back            更多文章                                      View English Version                      Put theory into practice!        上文中，我们了解了 ZFS 的各种优势以及缺陷。现在，我们将规划并创建一个真正的 ZFS 存储池。  由于将...",
  "links": [
    "https://szclsya.me/zh-cn/posts/storage/zfs-setup/"
  ],
  "image": "https://szclsya.me/zh-cn/posts/storage/zfs-setup/favicon.svg",
  "content": "<div>\n        <p>\n          <a target=\"_blank\" href=\"https://szclsya.me/zh-cn/posts\">\n            <svg>Arrow Back</svg>\n            <span>更多文章</span>\n          </a><a target=\"_blank\" href=\"https://szclsya.me/posts/storage/zfs-setup/\">\n              <svg width=\"24px\"></svg>\n              <span>View English Version</span>\n            </a></p>\n          <h2>Put theory into practice!</h2>\n        <article>\n<p>\n上文中，我们了解了 ZFS 的各种优势以及缺陷。现在，我们将规划并创建一个真正的 ZFS 存储池。</p>\n<div>\n  <p>\n由于将 ZFS 作为根文件系统需要内核在启动极早期就载入相关内核模块，各个发行版/OS 的相应配置方法都不太一样。因此，本文只会涉及仅用于存储用途的 ZFS 存储池。如果你想把整个系统装在 ZFS 上，请参阅你所使用的发行版/OS 的 Wiki 或用户手册。</p>\n</div>\n<div>\n<h2 id=\"headline-1\">\n相关概念\n</h2>\n<div>\n<p>许多常见的文件系统都被设计用在一个单独的分区或者逻辑卷上（例如 ext3/4 及 NTFS）。ZFS 则整合了逻辑卷管理功能，因此一个存储池可以被部署在许多块存储盘之上。存储池在 ZFS 中被称为 <code>zpool</code> 。在一个 zpool 里面可以存在多个 <code>VDEV (Virtual DEVices, 虚拟设备)</code> 。写入 zpool 的数据将被分散到各个 VDEV 上，有点类似于 RAID0<sup><a target=\"_blank\" href=\"https://szclsya.me/zh-cn/posts/storage/zfs-setup/#footnote-1\">1</a></sup>。</p>\n<p>\n如果你曾经配过 RAID 阵列的话，这样做也许听上去蠢极了，毕竟只要一个 VDEV 失效，整个阵列就完蛋了。不过 ZFS 允许在 VDEV 级别上创建冗余，这样就可以保证 VDEV 在合理的冗余配置下不会轻易失效。这样做也使扩展和收缩存储池极为灵活：只需增减 VDEV 即可。集成逻辑卷管理及 RAID 也意味着硬件 RAID 系统中常见的 <a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/RAID#WRITE-HOLE\">Write hole</a> 问题不会影响到 ZFS。</p>\n<p>\n为了适应不同的可靠性要求，存储数据的 VDEV 分为以下几种：</p>\n<ul>\n<li>single: 简单的单盘 VDEV，无冗余</li>\n<li>\n<p><strong>mirror</strong>: 镜像 VDEV，允许多块存储盘，只要一块可用就可以保证数据安全，性能最高</p>\n<ul>\n<li>类似于 RAID 1</li>\n</ul>\n</li>\n<li>\n<p><strong>RAIDz1, RAIDz2, RAIDz3</strong>: 允许多块存储盘，各自在数据丢失前允许 1/2/3 块盘失效</p>\n<ul>\n<li>相应的，最少需要 3/4/5 块存储盘</li>\n<li>使用校验信息块，类似于 RAID 5/6</li>\n</ul>\n</li>\n</ul>\n<div>\n<h3 id=\"headline-2\">\n空间效率及容错率\n</h3>\n<div>\n<p><code>mirror</code> 计算起来很简单：你将获得单盘的空间大小。只要阵列中有一块盘还活着，数据就不会丢失。</p>\n<p>\n<code>RAIDz</code> 阵列需要至少 \\( 2 + p \\) 块存储盘（\\( p \\) 代表 RAIDz 冗余等级，RAIDz 中 p 为 1，RAIDz2 中为 2，RAIDz3 中为 3）。举个例子，假设所有盘都是相同容量：</p>\n<ul>\n<li>\n<p>2 存储盘 + 1 冗余盘 (RAIDz1)</p>\n<ul>\n<li>\\( \\frac{2}{2+1} \\approx 66.7\\% \\) 空间效率，允许 3 块盘中损失 1 块</li>\n</ul>\n</li>\n<li>\n<p>4 存储盘 + 1 冗余盘 (RAIDz1)</p>\n<ul>\n<li>\\( \\frac{4}{4+1} = 80\\% \\) 空间效率，允许 5 块盘中损失 1 块</li>\n</ul>\n</li>\n<li>\n<p>4 存储盘 + 2 冗余盘 (RAIDz2)</p>\n<ul>\n<li>\\( \\frac{4}{4+2} \\approx 66.7\\% \\) 空间效率，允许 6 块盘中损失 2 块</li>\n</ul>\n</li>\n</ul>\n<p>需要注意的是如果混用不同容量的盘，则 ZFS 将把所有盘视作最小盘的大小。</p>\n</div>\n</div>\n</div>\n</div>\n<div>\n<h2 id=\"headline-3\">\n规划\n</h2>\n<div>\n<div>\n  <p>\nZFS 不允许缩小一块盘上的分区尺寸，且不能轻易转换 VDEV 的冗余类型。因此，请在将存储池投入使用前确保规划得当，否则后期调整将会相当麻烦。</p>\n</div>\n<p>\n对于任何存储系统来说，规划都是至关重要的。合理的存储结构能让你的硬件发挥最大效能，且在故障发生时能降低恢复难度。对于一个存储系统来说，规划时应该考虑到这几点：</p>\n<ol>\n<li>性能</li>\n<li>空间效率</li>\n<li>容错空间</li>\n</ol>\n<p>我们之前已经提过空间效率与容错了，因此这里主要介绍性能相关考量。一般而言，只需要在负载较大的系统上考虑性能问题即可（例如，zpool 上会承载数据库等），如果只是 NAS 用途的话无需过于担心。性能方面有这些常见的经验法则：</p>\n<ul>\n<li>如果预算允许，用 <code>mirror</code></li>\n<li>如果用 <code>RAIDz</code> 的话，一般会使用 \\( 2^n + p \\) 块存储盘以平衡性能与空间效率</li>\n</ul>\n<p>针对负载类型调整 ZFS 的运行参数也是很有效的做法，但这就超出本文讨论的范围了。</p>\n</div>\n</div>\n<div>\n<h2 id=\"headline-4\">\n创建阵列\n</h2>\n<div>\n<p>现在你应该已经想好存储池的大体结构了，现在是时候创建存储池了。</p>\n<div>\n  <p>\n这里列出的步骤主要针对 ZFS on Linux。在其他系统上虽然大体上是一样的，但有些参数可能需要修改（例如 FreeBSD）。具体请查阅相关手册与文档。</p>\n</div>\n<p>\n在 ZFS 中，存储池创建与维护相关工作是由 <code>zpool</code> 这个工具完成的。这个工具使用与 <code>git</code> 类似的子命令结构。这里，我们使用 <code>create</code> 子命令创建存储池：</p>\n<div>\n<table><tr><td>\n<pre><code><span>1\n</span></code></pre></td>\n<td>\n<pre><code><span><span>zpool create -f -o <span>ashift</span><span>=</span><span>12</span> -m &lt;mountpoint&gt; &lt;pool_name&gt; <span>[</span>raidz<span>|</span>raidz2<span>|</span>raidz3<span>|</span>mirror<span>]</span> &lt;volumes&gt;</span></span></code></pre></td></tr></table>\n</div>\n<ul>\n<li>\n<p><code>-f</code> 用于避免 <a target=\"_blank\" href=\"https://wiki.archlinux.org/title/ZFS#Does_not_contain_an_EFI_label\">Does not contain an EFI label</a> 错误。</p>\n<ul>\n<li>这个可能是 Linux 上的特定问题，在别的系统上可能不需要。无论怎么说，请参阅手册与文档。</li>\n</ul>\n</li>\n<li>\n<p><code>-o ashift=12</code> 使用现代硬盘原生支持的 AF (Advanced Format，先进格式化) 中的 4K 块大小以增进性能。如果你的存储池全部使用 SSD 的话，应使用 <code>-o ashift=13</code> (因为 SSD 一般使用 8K 块)</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://openzfs.github.io/openzfs-docs/Project%20and%20Community/FAQ.html#advanced-format-disks\">OpenZFS docs</a> 上有更多有关这个问题的信息。</li>\n</ul>\n</li>\n<li><code>-m &lt;mountpoint&gt;</code> 指定默认挂载点。</li>\n<li><code>&lt;pool_name&gt;</code> 指定存储池名。</li>\n<li><code>[raidz|raidz2|raidz3|mirror] &lt;volumes&gt;</code> 指定 VDEV 类型。不使用冗余则省略 VDEV 类型标识。注意这段可重复多次以创建拥有多个 VDEV 的阵列。</li>\n</ul>\n<p>在指定存储盘时注意使用盘的持久标识（如 <code>/dev/disks/by-id</code> 内标注的），而不是非持久标识（如 <code>sdX</code> 或 <code>nvmeX</code> ）。一旦硬盘排布发生变化（例如增减了硬盘），使用非持久标识的阵列在开机时可能会找不到或使用了错误的存储盘，而导致挂载失败。使用持久标识则可避免这个问题。</p>\n<div>\n<h3 id=\"headline-5\">\n例子：创建无冗余的单盘存储池\n</h3>\n<div>\n<div>\n<table><tr><td>\n<pre><code><span>1\n</span></code></pre></td>\n<td>\n<pre><code><span><span># zpool create -f -o ashift=12 -m /mnt/data data ata-VOLUME-ID</span></span></code></pre></td></tr></table>\n</div>\n<p>\n这里，我们在一块机械硬盘（ <code>/dev/disk/by-id/ata-VOLUME-ID</code> ）上创建了一个存储池，并挂载到了 <code>/mnt/data</code> 上。</p>\n</div>\n</div>\n<div>\n<h3 id=\"headline-6\">\n例子：创建由镜像 VDEV 组成的存储池\n</h3>\n<div>\n<div>\n<table><tr><td>\n<pre><code><span>1\n</span><span>2\n</span></code></pre></td>\n<td>\n<pre><code><span><span># zpool create -f -o ashift=12 -m /mnt/data data \\\n</span></span><span><span>      mirror ata-VOLUME-1 ata-VOLUME-2</span></span></code></pre></td></tr></table>\n</div>\n<p>\n这样就创建了一个拥有一个镜像 VDEV （由 <code>ata-VOLUME-1</code> 和 <code>ata-VOLUME-2</code> 组成）的存储池。</p>\n<p>\n也可以在创建时指定多个 VDEV:</p>\n<div>\n<table><tr><td>\n<pre><code><span>1\n</span><span>2\n</span><span>3\n</span></code></pre></td>\n<td>\n<pre><code><span><span># zpool create -f -o ashift=12 -m /mnt/data data \\\n</span></span><span><span>      mirror ata-VOLUME-1 ata-VOLUME-2 \\\n</span></span><span><span>      mirror ata-VOLUME-3 ata-VOLUME-4</span></span></code></pre></td></tr></table>\n</div>\n</div>\n</div>\n<div>\n<h3 id=\"headline-7\">\n例子：创建由 RAIDz1 VDEV 组成的存储池\n</h3>\n<div>\n<table><tr><td>\n<pre><code><span>1\n</span><span>2\n</span></code></pre></td>\n<td>\n<pre><code><span><span># zpool create -f -o ashift=12 -m /mnt/data data \\\n</span></span><span><span>      raidz ata-VOLUME-1 ata-VOLUME-2 ata-VOLUME-3 [...even more volumes]</span></span></code></pre></td></tr></table>\n</div>\n</div>\n</div>\n</div>\n<div>\n<h2 id=\"headline-8\">\n检查存储池状态\n</h2>\n<div>\n<p>创建完成后，我们就可以检查存储池的状态了:</p>\n<div>\n<table><tr><td>\n<pre><code><span> 1\n</span><span> 2\n</span><span> 3\n</span><span> 4\n</span><span> 5\n</span><span> 6\n</span><span> 7\n</span><span> 8\n</span><span> 9\n</span><span>10\n</span><span>11\n</span><span>12\n</span><span>13\n</span></code></pre></td>\n<td>\n<pre><code><span><span># zpool status data\n</span></span><span><span>  pool: data\n</span></span><span><span> state: ONLINE\n</span></span><span><span>  scan: none requested\n</span></span><span><span>config:\n</span></span><span><span>\n</span></span><span><span>        NAME                      STATE     READ WRITE CKSUM\n</span></span><span><span>        data                      ONLINE       0     0     0\n</span></span><span><span>          mirror-0                ONLINE       0     0     0\n</span></span><span><span>            ata-VOLUME-1          ONLINE       0     0     0\n</span></span><span><span>            ata-VOLUME-2          ONLINE       0     0     0\n</span></span><span><span>\n</span></span><span><span>errors: No known data errors</span></span></code></pre></td></tr></table>\n</div>\n<p>\n由于是新创建的存储池，现在这里还没什么可看的。不过在后续的运营中我们会在这里检查 scrub/阵列重建进度，检查存储盘状态，及检查哪些文件被数据丢失事件波及。</p>\n</div>\n</div>\n<div>\n<h2 id=\"headline-9\">\n添加及移除存储盘\n</h2>\n<div>\n<p>对于创建完成的存储池，我们也可以调整它的结构。</p>\n<div>\n<h3 id=\"headline-10\">\n添加新 VDEV\n</h3>\n<div>\n<p>我们可以通过添加一个新的 VDEV （可以是 single, mirror 和 RAIDz）的方式扩展存储池：</p>\n<div>\n<table><tr><td>\n<pre><code><span>1\n</span></code></pre></td>\n<td>\n<pre><code><span><span># zpool add [pool_name] [raidz|raidz2|raidz3|mirror] &lt;volumes&gt;</span></span></code></pre></td></tr></table>\n</div>\n<p>\n需要注意的是如果新 VDEV 有不同的冗余等级（例如，mirror 或 RAIDz 中数据盘的数量和存储池中其他 mirror 或 RAIDz 中的不同），ZFS 就会警告冗余等级不匹配。但一般来说，只要负载没有非常严重，这带来的性能损失是可以忽略不计的。</p>\n<p>\n<a target=\"_blank\" href=\"https://openzfs.github.io/openzfs-docs/man/8/zpool-add.8.html\">zpool-add.8</a> 上有更多有关这个操作的信息。</p>\n</div>\n</div>\n<div>\n<h3 id=\"headline-11\">\n将简单盘转为 mirror VDEV\n</h3>\n<div>\n<p>这个操作也可以被用来扩展已有的 mirror VDEV。</p>\n<div>\n<table><tr><td>\n<pre><code><span>1\n</span></code></pre></td>\n<td>\n<pre><code><span><span># zpool attach [pool_name] &lt;exisitng_volume/VDEV_name&gt; &lt;new_volumes&gt;</span></span></code></pre></td></tr></table>\n</div>\n<p>\n<a target=\"_blank\" href=\"https://openzfs.github.io/openzfs-docs/man/8/zpool-attach.8.html\">zpool-attach.8</a> 上有更多有关这个操作的信息。</p>\n</div>\n</div>\n<div>\n<h3 id=\"headline-12\">\n从存储池中去除设备\n</h3>\n<div>\n<p>目前，OpenZFS 只支持从不包含 RAIDz 的存储池中移除 single 和 mirror 类型的 VDEV。这个操作会把数据迁移至剩下的存储盘上，并相应地降低存储池的大小。</p>\n<div>\n<table><tr><td>\n<pre><code><span>1\n</span></code></pre></td>\n<td>\n<pre><code><span><span># zpool remove [pool_name] [devices]</span></span></code></pre></td></tr></table>\n</div>\n<p>\n<a target=\"_blank\" href=\"https://openzfs.github.io/openzfs-docs/man/8/zpool-remove.8.html\">zpool-remove.8</a> 上有更多有关这个操作的信息。</p>\n</div>\n</div>\n</div>\n</div>\n<div>\n<h2 id=\"headline-13\">\n导入和导出存储池\n</h2>\n<div>\n<p>如果要在别的设备/操作系统上使用存储池，首先需要将存储池导出。</p>\n<div>\n<table><tr><td>\n<pre><code><span>1\n</span></code></pre></td>\n<td>\n<pre><code><span><span># zpool export &lt;pool_name&gt;</span></span></code></pre></td></tr></table>\n</div>\n<p>\n导入存储池时需注意，ZFS on Linux 默认会使用非持久命名导入数据盘。为了避免磁盘排布变化造成无法开机时载入存储池，导入时应注明从哪个位置搜索磁盘：</p>\n<div>\n<table><tr><td>\n<pre><code><span>1\n</span></code></pre></td>\n<td>\n<pre><code><span><span># zpool import -d /dev/disk/by-id &lt;pool_name&gt;</span></span></code></pre></td></tr></table>\n</div>\n</div>\n</div>\n</article>\n    </div>",
  "author": "Leo Shen",
  "favicon": "",
  "source": "szclsya.me",
  "published": "2022-03-21T15:49:04Z",
  "ttr": 101,
  "type": "website"
}